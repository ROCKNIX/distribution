From 5498f34ea84f7182e9ef7a0c36bd480dea99ef18 Mon Sep 17 00:00:00 2001
From: Philippe Simons <simons.philippe@gmail.com>
Date: Wed, 15 Jan 2025 19:13:28 +0100
Subject: [PATCH] enable usb otg

---
 .../sun50i-h700-anbernic-rg35xx-2024.dts      | 23 ++++++-
 .../sun50i-h700-anbernic-rg35xx-h.dts         |  6 +-
 drivers/phy/allwinner/phy-sun4i-usb.c         | 66 +++++++++++++++++--
 3 files changed, 84 insertions(+), 11 deletions(-)

diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
index 7fded0538..f105df43b 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
@@ -339,6 +339,16 @@ h616_vqmmc_regulator: mmc-regulator {
 		regulator-max-microvolt = <3300000>;
 		regulator-boot-on;
 	};
+
+	reg_usb0_vbus: regulator-usb0-vbus {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 8 16 GPIO_ACTIVE_HIGH>; /* PI16 */
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "usb0-vbus";
+		vin-supply = <&reg_boost>;
+	};
 };
 
 &codec {
@@ -589,11 +599,22 @@ &uart0 {
 
 /* the AXP717 has USB type-C role switch functionality, not yet described by the binding */
 &usbotg {
-	dr_mode = "peripheral";   /* USB type-C receptable */
+	dr_mode = "otg";   /* USB type-C receptable */
+	status = "okay";
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ohci0 {
 	status = "okay";
 };
 
 &usbphy {
+	usb0_id_det-gpios = <&pio 8 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	usb0_vbus_power-supply = <&usb_power>;
+	usb0_vbus-supply = <&reg_usb0_vbus>;
 	status = "okay";
 };
 
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
index 652e03ea8..ef55a6fd8 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
@@ -20,13 +20,13 @@ reg_vcc3v8_usb: regulator-vcc3v8-usb {
 		regulator-name = "vcc3v8-usb";
 	};
 
-	reg_vcc5v0_usb: regulator-vcc5v0-usb {
+	reg_usb1_vbus: regulator-usb1-vbus {
 		compatible = "regulator-fixed";
 		enable-active-high;
 		gpio = <&pio 8 7 GPIO_ACTIVE_HIGH>; /* PI7 */
 		regulator-min-microvolt = <5000000>;
 		regulator-max-microvolt = <5000000>;
-		regulator-name = "vcc5v0-usb";
+		regulator-name = "usb1-vbus";
 		vin-supply = <&reg_vcc3v8_usb>;
 	};
 };
@@ -44,5 +44,5 @@ &ohci1 {
 };
 
 &usbphy {
-	usb1_vbus-supply = <&reg_vcc5v0_usb>;
+	usb1_vbus-supply = <&reg_usb1_vbus>;
 };
diff --git a/drivers/phy/allwinner/phy-sun4i-usb.c b/drivers/phy/allwinner/phy-sun4i-usb.c
index b0f19e950..612797320 100644
--- a/drivers/phy/allwinner/phy-sun4i-usb.c
+++ b/drivers/phy/allwinner/phy-sun4i-usb.c
@@ -465,6 +465,10 @@ static int sun4i_usb_phy_power_on(struct phy *_phy)
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 	int ret;
 
+	/* phy0 is controlled by sun4i_usb_phy0_id_vbus_det_scan and id_det state */
+	if (phy->index == 0)
+		return 0;
+
 	if (!phy->vbus || phy->regulator_on)
 		return 0;
 
@@ -493,6 +497,10 @@ static int sun4i_usb_phy_power_off(struct phy *_phy)
 	struct sun4i_usb_phy *phy = phy_get_drvdata(_phy);
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 
+	/* phy0 is controlled by sun4i_usb_phy0_id_vbus_det_scan and id_det state */
+	if (phy->index == 0)
+		return 0;
+
 	if (!phy->vbus || !phy->regulator_on)
 		return 0;
 
@@ -509,6 +517,17 @@ static int sun4i_usb_phy_power_off(struct phy *_phy)
 	return 0;
 }
 
+static void sun4i_usb_phy0_set_dr_mode(struct sun4i_usb_phy_data *data, int new_mode)
+{
+	if (new_mode != data->dr_mode) {
+		dev_info(&data->phys[0].phy->dev, "Changing dr_mode to %d\n", new_mode);
+		data->dr_mode = new_mode;
+	}
+	data->id_det = -1; /* Force reprocessing of id */
+	data->force_session_end = true;
+	queue_delayed_work(system_wq, &data->detect, 0);
+}
+
 static int sun4i_usb_phy_set_mode(struct phy *_phy,
 				  enum phy_mode mode, int submode)
 {
@@ -536,14 +555,19 @@ static int sun4i_usb_phy_set_mode(struct phy *_phy,
 		return -EINVAL;
 	}
 
-	if (new_mode != data->dr_mode) {
-		dev_info(&_phy->dev, "Changing dr_mode to %d\n", new_mode);
-		data->dr_mode = new_mode;
+	if (data->cfg->phy0_dual_route) {
+		/*
+		 For SoCs with dual route the PHY mode is fully determined by 
+		 the selected mux route (i.e. USB controller to use).
+		 As both host (EHCI/OHCI) and peripheral (MUSB) controllers uses
+		 the same PHY, both drivers can try to set PHY mode.
+		 We need to ignore this requests, but not report error in case
+		 of valid mode values.
+		*/
+		return 0;
 	}
 
-	data->id_det = -1; /* Force reprocessing of id */
-	data->force_session_end = true;
-	queue_delayed_work(system_wq, &data->detect, 0);
+	sun4i_usb_phy0_set_dr_mode(data, new_mode);
 
 	return 0;
 }
@@ -603,6 +627,26 @@ static void sun4i_usb_phy0_id_vbus_det_scan(struct work_struct *work)
 		return;
 	}
 
+	/* stop reg if there is a vbus */
+	if (vbus_det != 0) {
+		if (phy->regulator_on) {
+			regulator_disable(phy->vbus);
+			phy->regulator_on = false;		
+		}
+	} else {
+		/* there is a periph connected and regulator is off */
+		if (id_det == 0 && !phy->regulator_on) {
+			regulator_enable(phy->vbus);
+			phy->regulator_on = true;	
+		}
+
+		/* there is no periph and regulator is on*/
+		if (id_det != 0 && phy->regulator_on) {
+			regulator_disable(phy->vbus);
+			phy->regulator_on = false;	
+		}
+	}
+
 	force_session_end = data->force_session_end;
 	data->force_session_end = false;
 
@@ -766,7 +810,15 @@ static int sun4i_usb_phy_probe(struct platform_device *pdev)
 			return -EPROBE_DEFER;
 	}
 
-	data->dr_mode = of_usb_get_dr_mode_by_phy(np, 0);
+	data->dr_mode = usb_get_dr_mode(dev);
+	if (data->dr_mode == USB_DR_MODE_UNKNOWN) {
+		data->dr_mode = of_usb_get_dr_mode_by_phy(np, 0);
+		if (data->dr_mode == USB_DR_MODE_UNKNOWN) {
+			data->dr_mode = USB_DR_MODE_OTG;
+		}
+	}
+
+	dev_info(dev, "phy0 dr_mode=%d\n",data->dr_mode);
 
 	data->extcon = devm_extcon_dev_allocate(dev, sun4i_usb_phy0_cable);
 	if (IS_ERR(data->extcon)) {
-- 
2.47.1

